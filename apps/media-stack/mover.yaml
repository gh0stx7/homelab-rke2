apiVersion: v1
kind: ConfigMap
metadata:
  name: media-mover-script
data:
  mover.sh: |
    #!/bin/bash
    HOT="/media/hot"
    COLD="/media/cold"

    THRESHOLD_PERCENT="${THRESHOLD_PERCENT:-80}"
    TARGET_PERCENT="${TARGET_PERCENT:-70}"
    MIN_FREE_GB="${MIN_FREE_GB:-50}"

    RADARR_API="http://radarr:7878/api/v3"
    SONARR_API="http://sonarr:8989/api/v3"
    RADARR_KEY="${RADARR_API_KEY}"
    SONARR_KEY="${SONARR_API_KEY}"

    # Operational Modes
    DRY_RUN="${DRY_RUN:-false}"
    MAX_FILES="${MAX_FILES:-0}"
    DRAIN_MODE="${DRAIN_MODE:-false}"
    SKIP_HYDRATION="${SKIP_HYDRATION:-false}"

    get_usage_percent() { df "$HOT" | awk 'NR==2 {gsub(/%/,"",$5); print $5}'; }
    get_free_gb() { df -BG "$HOT" | awk 'NR==2 {gsub(/G/,"",$4); print $4}'; }

    calculate_space_needed() {
        local current=$1
        local target=$2
        local total_bytes
        total_bytes=$(df -B1 "$HOT" | awk 'NR==2 {print $2}')
        if [ "$current" -gt "$target" ]; then
            # Use awk for large number math to avoid Bash 32-bit/64-bit integer overflows
            awk -v cur="$current" -v tar="$target" -v tot="$total_bytes" 'BEGIN {print int((cur - tar) * tot / 100)}'
        else
            echo "0"
        fi
    }

    iso_to_epoch() {
        local iso_date="$1"
        iso_date="${iso_date%.*}"
        iso_date="${iso_date%Z}"
        local year month day hour minute second
        year="${iso_date:0:4}"
        month="${iso_date:5:2}"
        day="${iso_date:8:2}"
        hour="${iso_date:11:2}"
        minute="${iso_date:14:2}"
        second="${iso_date:17:2}"
        date -u -d "${year}-${month}-${day} ${hour}:${minute}:${second}" +%s 2>/dev/null || echo "0"
    }

    hydrate_symlinks() {
        if [ "$SKIP_HYDRATION" = "true" ]; then return; fi
        echo "[Hydration] Restoring symlinks..."
        [ ! -d "$COLD" ] && return 1
        cd "$COLD" || return 1
        find . -type d -print0 | xargs -0 -I {} mkdir -p "$HOT/{}"
        while IFS= read -r FILE; do
            HOT_PATH="$HOT/$FILE"
            COLD_PATH="$COLD/$FILE"
            [ -f "$HOT_PATH" ] && [ ! -L "$HOT_PATH" ] && continue
            if [ -L "$HOT_PATH" ]; then
                [ "$(readlink "$HOT_PATH")" = "$COLD_PATH" ] && continue
                rm "$HOT_PATH"
            fi
            ln -s "$COLD_PATH" "$HOT_PATH" 2>/dev/null
        done < <(find . -type f -not -name ".*")
    }

    get_movies_by_age() {
        # Added tr -d to strip quotes and carriage returns from API response
        curl -s "${RADARR_API}/moviefile" -H "X-Api-Key: ${RADARR_KEY}" | \
        jq -r '.[] | "\(.dateAdded)|\(.path)|\(.size)"' | tr -d '\r"'
    }

    get_episodes_by_age() {
        local SERIES_IDS
        SERIES_IDS=$(curl -s "${SONARR_API}/series" -H "X-Api-Key: ${SONARR_KEY}" | jq -r '.[].id')
        for ID in $SERIES_IDS; do
            curl -s "${SONARR_API}/episodefile?seriesId=${ID}" -H "X-Api-Key: ${SONARR_KEY}" | \
            jq -r '.[] | "\(.dateAdded)|\(.path)|\(.size)"' | tr -d '\r"'
        done
    }

    archive_file() {
        local DATE_ADDED="$1"
        local FILE_PATH="$2"
        local FILE_SIZE="$3"

        [[ "$FILE_PATH" != "$HOT"* ]] && return 1
        [ -L "$FILE_PATH" ] && return 1
        [ ! -f "$FILE_PATH" ] && return 1

        local DEST="${FILE_PATH/$HOT/$COLD}"
        if [ -f "$DEST" ]; then
            [ "$DRY_RUN" = "false" ] && rm -f "$FILE_PATH" && ln -s "$DEST" "$FILE_PATH"
            return 1
        fi

        local NOW=$(date +%s)
        local ADDED_EPOCH=$(iso_to_epoch "$DATE_ADDED")
        [ "$ADDED_EPOCH" = "0" ] && ADDED_EPOCH="$NOW"
        local AGE_DAYS=$(( (NOW - ADDED_EPOCH) / 86400 ))
        local SIZE_GB=$(awk -v s="$FILE_SIZE" 'BEGIN {printf "%.2f", s/1073741824}')

        if [ "$DRY_RUN" = "true" ]; then
            echo "[DRY-RUN] Would archive: ${SIZE_GB}GB | ${AGE_DAYS}d | $(basename "$FILE_PATH")"
            return 0
        fi

        mkdir -p "$(dirname "$DEST")"
        if mv "$FILE_PATH" "$DEST"; then
            ln -s "$DEST" "$FILE_PATH" && echo "[Archive] âœ“ ${SIZE_GB}GB | $(basename "$FILE_PATH")"
            return 0
        fi
        return 1
    }

    # --- Main Execution ---
    hydrate_symlinks

    while true; do
        CUR_PERC=$(get_usage_percent)
        FREE_GB=$(get_free_gb)

        SHOULD_ARCHIVE=false
        if [ "$DRAIN_MODE" = "true" ]; then
            SHOULD_ARCHIVE=true
            SPACE_TO_FREE=999999999999999
        elif [ "$CUR_PERC" -gt "$THRESHOLD_PERCENT" ] || [ "$FREE_GB" -lt "$MIN_FREE_GB" ]; then
            SHOULD_ARCHIVE=true
            SPACE_TO_FREE=$(calculate_space_needed "$CUR_PERC" "$TARGET_PERCENT")
        fi

        if [ "$SHOULD_ARCHIVE" = "true" ]; then
            SPACE_FREED=0
            FILES_ARCHIVED=0

            # Use a temporary file to avoid pipe issues with large lists
            TMP_LIST=$(mktemp)
            { get_movies_by_age; get_episodes_by_age; } | sort -t'|' -k1 > "$TMP_LIST"

            while IFS='|' read -r DATE_ADDED FILE_PATH FILE_SIZE; do
                [ -z "$FILE_PATH" ] && continue

                # Use awk for comparison to handle very large integers (bytes) safely
                if [ "$DRAIN_MODE" = "false" ] && [ "$(awk -v sf="$SPACE_FREED" -v stf="$SPACE_TO_FREE" 'BEGIN {print (sf >= stf)}')" -eq 1 ]; then
                    break
                fi

                if archive_file "$DATE_ADDED" "$FILE_PATH" "$FILE_SIZE"; then
                    # Safe addition
                    SPACE_FREED=$(awk -v sf="$SPACE_FREED" -v fs="$FILE_SIZE" 'BEGIN {print sf + fs}')
                    FILES_ARCHIVED=$(( FILES_ARCHIVED + 1 ))
                fi

                [ "$MAX_FILES" -gt 0 ] && [ "$FILES_ARCHIVED" -ge "$MAX_FILES" ] && break
            done < "$TMP_LIST"
            rm -f "$TMP_LIST"
        fi

        [ "$DRY_RUN" = "true" ] || [ "$DRAIN_MODE" = "true" ] && exit 0
        sleep 300
    done
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: media-mover
spec:
  replicas: 1
  selector:
    matchLabels: { app: media-mover }
  template:
    metadata:
      labels: { app: media-mover }
    spec:
      affinity:
        podAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            - labelSelector:
                matchExpressions:
                  - key: stack
                    operator: In
                    values: [ "media-anchor" ]
              topologyKey: "kubernetes.io/hostname"
      containers:
        - name: mover
          image: alpine:latest
          command:
            - "/bin/sh"
            - "-c"
            - "apk add --no-cache bash findutils coreutils curl jq && /bin/bash /scripts/mover.sh"
          env:
            # API Keys from secret
            - name: RADARR_API_KEY
              valueFrom:
                secretKeyRef:
                  name: media-api-keys
                  key: radarr-api-key
            - name: SONARR_API_KEY
              valueFrom:
                secretKeyRef:
                  name: media-api-keys
                  key: sonarr-api-key
            # Optional: Override defaults
            - name: THRESHOLD_PERCENT
              value: "40"
            - name: TARGET_PERCENT
              value: "30"
            - name: MIN_FREE_GB
              value: "50"
            # Operational modes (for testing)
            - name: DRY_RUN
              value: "true"
            - name: MAX_FILES
              value: "5"
            # - name: DRAIN_MODE
            #   value: "false"
          volumeMounts:
            - { name: script, mountPath: /scripts }
            - { name: hot, mountPath: /media/hot }
            - { name: cold, mountPath: /media/cold }
          resources:
            requests:
              cpu: "100m"
              memory: "256Mi"
      volumes:
        - name: script
          configMap: { name: media-mover-script, defaultMode: 0755 }
        - name: hot
          persistentVolumeClaim: { claimName: media-hot-pvc }
        - name: cold
          persistentVolumeClaim: { claimName: media-nfs-pvc }
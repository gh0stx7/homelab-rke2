authentik:
  # Secrets are injected via environment variables below
  secret_key: ""

  error_reporting:
    enabled: true

  log_level: info

  postgresql:
    password: ""  # Injected via env var

  # Email configuration
  email:
    host: smtp.gmail.com
    port: 587
    username: bertlongarms@gmail.com
    password: ""  # Injected via env var
    use_tls: true
    use_ssl: false
    timeout: 30
    from: authentik@ghostlabz.net

  # Environment variables to inject secrets
  env:
    - name: AUTHENTIK_SECRET_KEY
      valueFrom:
        secretKeyRef:
          name: authentik-secrets
          key: secret-key
    - name: AUTHENTIK_POSTGRESQL__PASSWORD
      valueFrom:
        secretKeyRef:
          name: authentik-secrets
          key: db-password
    - name: AUTHENTIK_EMAIL__PASSWORD
      valueFrom:
        secretKeyRef:
          name: authentik-secrets
          key: email-password

server:
  replicas: 2

  resources:
    requests:
      cpu: 500m
      memory: 512Mi
    limits:
      cpu: 2000m
      memory: 2Gi

  # Disable built-in ingress - we'll create separate ingresses for external/internal
  ingress:
    enabled: false

worker:
  replicas: 1

  resources:
    requests:
      cpu: 250m
      memory: 256Mi
    limits:
      cpu: 1000m
      memory: 1Gi

# =============================================================================
# POSTGRESQL (BUNDLED) - Using longhorn-2r
# =============================================================================
# Why longhorn-2r with 2 replicas?
# - Authentik user database is CRITICAL (passwords, MFA secrets, sessions)
# - longhorn-2r offers better performance than v1
# - 2 replicas provides HA without 3x space overhead (recommended by Longhorn docs)
# - Harvester's v2 implementation is production-ready as of v1.6.1
postgresql:
  enabled: true

  auth:
    username: authentik
    database: authentik
    # Use existing secret created by sealed-secrets
    existingSecret: authentik-secrets
    secretKeys:
      adminPasswordKey: db-password
      userPasswordKey: db-password

  # Persistent storage - CRITICAL DATA
  primary:
    persistence:
      enabled: true
      storageClass: longhorn-2r
      size: 10Gi
      accessModes:
        - ReadWriteOnce

    # Resource allocation
    resources:
      requests:
        cpu: 250m
        memory: 256Mi
      limits:
        cpu: 1000m
        memory: 1Gi

    # PostgreSQL tuning for authentication workload
    extraEnvVars:
      - name: POSTGRESQL_MAX_CONNECTIONS
        value: "200"
      - name: POSTGRESQL_SHARED_BUFFERS
        value: "128MB"
      - name: POSTGRESQL_EFFECTIVE_CACHE_SIZE
        value: "512MB"

# =============================================================================
# REDIS (BUNDLED) - Using longhorn-2r
# =============================================================================
# Why longhorn-2r (2 replicas)?
# - Redis stores sessions and cache (ephemeral data)
# - Small footprint (~2GB total with 2 replicas = 4GB)
# - Fast rebuild if node fails
# - Using 2 replicas for consistency with PostgreSQL
redis:
  enabled: true

  architecture: standalone  # Single master (not sentinel/cluster)

  auth:
    enabled: false  # Authentik handles auth, Redis is internal-only

  master:
    persistence:
      enabled: true
      storageClass: longhorn-2r
      size: 2Gi
      accessModes:
        - ReadWriteOnce

    # Resource allocation
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 512Mi

    # Redis configuration for session storage
    configuration: |-
      maxmemory 256mb
      maxmemory-policy allkeys-lru
      save 900 1
      save 300 10
      save 60 10000

# =============================================================================
# GLOBAL SETTINGS
# =============================================================================
global:
  # Security context
  securityContext:
    runAsNonRoot: true
    runAsUser: 1000
    fsGroup: 1000

  # Prometheus monitoring (optional)
  addPrometheusAnnotations: false

  # Pod disruption budget (optional - enable after initial deployment)
  # podDisruptionBudget:
  #   enabled: true
  #   minAvailable: 1